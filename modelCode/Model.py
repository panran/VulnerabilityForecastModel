import matplotlib.pylab as plt
import math

def PMGTV_Model(M,A,B,Alph,Beta,time):
    #模型参数为5个
    y=[]
    for k in range(time):
        #time表示横向时间轴的长度
        value = M/math.pow(1+math.pow(math.e,A*(B-k)),math.pow(Alph,k)+Beta)
        y.append(value)
    return y

def RE_Model(N,Gama,time):
    y=[]
    for i in range(time):
        #y.append((K/Gama)*math.log(3,C^time))
        value =  N*(1-(math.pow(math.e,-Gama*i)))
        y.append(value)
        y[0]=0.00004
    #print(y)
    return y

def AT_Model(K,Gama,C,time):
    y = []
    for i in range(time):
        value = (K/Gama)*math.log(C*(i+1))
        y.append(value)

    #print(y)
    return y

def LP_Model(A,B,time):
    y = []
    for i in range(time):
        value = A * math.log(1 + B*i)
        y.append(value)

    #print(y)
    return y

def AML_Model(A,B,C,time):
    y = []
    for i in range(time):
        value = B/(1+B*C*math.pow(math.e,(-A*B*i)))
        y.append(value)

    #print(y)
    return y

def SSE(y_predict,y_actual):
    SSE = 0
    for i in range(len(y_actual)):
        SSE = SSE + math.pow((y_actual[i]-y_predict[i]),2)
    return SSE

def Kafang(y_predict,y_actual):
    kaFang = 0
    for i in range(len(y_actual)):
       # print(y_predict[i])
        kaFang = kaFang + (math.pow((y_actual[i] - y_predict[i]), 2)/(y_predict[i]+0.000002))
    return kaFang

def Print():
    print("hello")